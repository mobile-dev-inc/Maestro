/*
 *
 *  Copyright (c) 2022 mobile.dev inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 */

package maestro.cli.command

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import maestro.TreeNode
import maestro.cli.App
import maestro.cli.DisableAnsiMixin
import maestro.cli.ShowHelpMixin
import maestro.cli.analytics.Analytics
import maestro.cli.analytics.PrintHierarchyFinishedEvent
import maestro.cli.analytics.PrintHierarchyStartedEvent
import maestro.cli.mcp.tools.ViewHierarchyFormatters
import maestro.cli.report.TestDebugReporter
import maestro.cli.session.MaestroSessionManager
import maestro.cli.view.yellow
import maestro.utils.CliInsights
import maestro.utils.Insight
import maestro.utils.chunkStringByWordCount
import picocli.CommandLine
import picocli.CommandLine.Option
import java.lang.StringBuilder

@CommandLine.Command(
    name = "hierarchy",
    description = [
        "Print out the view hierarchy of the connected device"
    ]
)
class PrintHierarchyCommand : Runnable {

    @CommandLine.Mixin
    var disableANSIMixin: DisableAnsiMixin? = null

    @CommandLine.Mixin
    var showHelpMixin: ShowHelpMixin? = null

    @CommandLine.ParentCommand
    private val parent: App? = null

    @CommandLine.Option(
        names = ["--android-webview-hierarchy"],
        description = ["Set to \"devtools\" to use Chrome dev tools for Android WebView hierarchy"],
        hidden = true,
    )
    private var androidWebViewHierarchy: String? = null

    @CommandLine.Option(
        names = ["--reinstall-driver"],
        description = ["Reinstalls driver before running the test. On iOS, reinstalls xctestrunner driver. On Android, reinstalls both driver and server apps. Set to false to skip reinstallation."],
        negatable = true,
        defaultValue = "true",
        fallbackValue = "true"        
    )
    private var reinstallDriver: Boolean = true

    @Option(
        names = ["--apple-team-id"],
        description = ["The Team ID is a unique 10-character string generated by Apple that is assigned to your team's apple account."],
        hidden = true
    )
    private var appleTeamId: String? = null

    @CommandLine.Option(
        names = ["--compact"],
        description = ["Output in CSV format with element_num,depth,attributes,parent_num columns"],
        hidden = false
    )
    private var compact: Boolean = false

    @CommandLine.Option(
        names = ["--simple"],
        description = ["Simple flat JSON format with package names, coordinates, and abbreviated keys for easy parsing"],
        hidden = false
    )
    private var simpleFormat: Boolean = false

    @CommandLine.Option(
        names = ["--app"],
        description = ["[Android only] Filter elements by package name (e.g., com.example.myapp)"],
        hidden = false
    )
    private var appFilter: String? = null

    @CommandLine.Option(
        names = ["--exclude-apps"],
        description = ["[Android only] Comma-separated list of package names to exclude (default: com.android.systemui). If specified, the default is NOT included - add it explicitly if needed."],
        split = ",",
        hidden = false
    )
    private var excludeApps: List<String> = emptyList()

    @CommandLine.Option(
        names = ["--exclude-apps-file"],
        description = ["[Android only] Path to file containing package names to exclude (one per line). If specified, the default is NOT included."],
        hidden = false
    )
    private var excludeAppsFile: java.io.File? = null

    @CommandLine.Option(
        names = ["--clickable-only"],
        description = ["Only show clickable/interactive elements"],
        hidden = false
    )
    private var clickableOnly: Boolean = false

    @CommandLine.Option(
        names = ["--with-id"],
        description = ["Include element_num (id), depth, and parent_num fields in the output"],
        hidden = false
    )
    private var withId: Boolean = false

    @CommandLine.Option(
        names = ["--multi-line"],
        description = ["Format output with indentation and newlines for human readability"],
        hidden = false
    )
    private var multiLine: Boolean = false

    @CommandLine.Option(
        names = ["--output"],
        description = ["Write output to a file instead of stdout"],
        hidden = false
    )
    private var outputFile: java.io.File? = null

    @CommandLine.Option(
        names = ["--device-index"],
        description = ["The index of the device to run the test on"],
        hidden = true
    )
    private var deviceIndex: Int? = null

    override fun run() {
        TestDebugReporter.install(
            debugOutputPathAsString = null,
            flattenDebugOutput = false,
            printToConsole = parent?.verbose == true,
        )
        
        // Track print hierarchy start
        val platform = parent?.platform ?: "unknown"
        val startTime = System.currentTimeMillis()
        Analytics.trackEvent(PrintHierarchyStartedEvent(platform = platform))
        

        MaestroSessionManager.newSession(
            host = parent?.host,
            port = parent?.port,
            driverHostPort = null,
            teamId = appleTeamId,
            deviceId = parent?.deviceId,
            platform = parent?.platform,
            reinstallDriver = reinstallDriver,
            deviceIndex = deviceIndex
        ) { session ->
            session.maestro.setAndroidChromeDevToolsEnabled(androidWebViewHierarchy == "devtools")
            val callback: (Insight) -> Unit = {
                val message = StringBuilder()
                val level = it.level.toString().lowercase().replaceFirstChar(Char::uppercase)
                message.append(level.yellow() + ": ")
                it.message.chunkStringByWordCount(12).forEach { chunkedMessage ->
                    message.append("$chunkedMessage ")
                }
                println(message.toString())
            }
            val insights = CliInsights

            insights.onInsightsUpdated(callback)

            val tree = session.maestro.viewHierarchy().root

            insights.unregisterListener(callback)

            if (simpleFormat) {
                // Simple flat JSON output format - use pixel dimensions
                val deviceInfo = session.maestro.deviceInfo()
                val screenWidth = deviceInfo.widthPixels
                val screenHeight = deviceInfo.heightPixels

                // Build exclude apps set
                val excludeAppsSet = buildExcludeAppsSet()

                val output = ViewHierarchyFormatters.extractLLMOutput(
                    node = tree,
                    screenWidth = screenWidth,
                    screenHeight = screenHeight,
                    appFilter = appFilter,
                    excludeApps = excludeAppsSet,
                    clickableOnly = clickableOnly,
                    prettyPrint = multiLine,
                    withId = withId
                )
                
                if (outputFile != null) {
                    outputFile!!.writeText(output)
                } else {
                    println(output)
                }
            } else if (compact) {
                // Output in CSV format
                println("element_num,depth,attributes,parent_num")
                val nodeToId = mutableMapOf<TreeNode, Int>()
                val csv = StringBuilder()
                
                // Assign IDs to each node
                var counter = 0
                tree?.aggregate()?.forEach { node ->
                    nodeToId[node] = counter++
                }
                
                // Process tree recursively to generate CSV
                processTreeToCSV(tree, 0, null, nodeToId, csv)
                
                println(csv.toString())
            } else {
                // Original JSON output format
                val hierarchy = jacksonObjectMapper()
                    .setSerializationInclusion(JsonInclude.Include.NON_NULL)
                    .writerWithDefaultPrettyPrinter()
                    .writeValueAsString(tree)
                
                println(hierarchy)
            }
        }
        
        // Track successful completion
        val duration = System.currentTimeMillis() - startTime
        Analytics.trackEvent(PrintHierarchyFinishedEvent(
            platform = platform,
            success = true,
            durationMs = duration
        ))
        Analytics.flush()
    }
    
    private fun processTreeToCSV(
        node: TreeNode?, 
        depth: Int, 
        parentId: Int?, 
        nodeToId: Map<TreeNode, Int>,
        csv: StringBuilder
    ) {
        if (node == null) return
        
        val nodeId = nodeToId[node] ?: return
        
        // Build attributes string
        val attributesList = mutableListOf<String>()
        
        // Add normal attributes
        node.attributes.forEach { (key, value) ->
            if (value.isNotEmpty() && value != "false") {
                attributesList.add("$key=$value")
            }
        }
        
        // Add boolean properties if true
        if (node.clickable == true) attributesList.add("clickable=true")
        if (node.enabled == true) attributesList.add("enabled=true")
        if (node.focused == true) attributesList.add("focused=true")
        if (node.checked == true) attributesList.add("checked=true")
        if (node.selected == true) attributesList.add("selected=true")
        
        // Join all attributes with "; "
        val attributesString = attributesList.joinToString("; ")
        
        // Escape quotes in the attributes string if needed
        val escapedAttributes = attributesString.replace("\"", "\"\"")
        
        // Add this node to CSV
        csv.append("$nodeId,$depth,\"$escapedAttributes\",${parentId ?: ""}\n")
        
        // Process children
        node.children.forEach { child ->
            processTreeToCSV(child, depth + 1, nodeId, nodeToId, csv)
        }
    }

    private fun removeEmptyValues(tree: TreeNode?): TreeNode? {
        if (tree == null) {
            return null
        }

        return TreeNode(
            attributes = tree.attributes.filter {
                it.value != "" && it.value.toString() != "false"
            }.toMutableMap(),
            children = tree.children.map { removeEmptyValues(it) }.filterNotNull(),
            checked = if(tree.checked == true) true else null,
            clickable = if(tree.clickable == true) true else null,
            enabled = if(tree.enabled == true) true else null,
            focused = if(tree.focused == true) true else null,
            selected = if(tree.selected == true) true else null,
        )
    }

    /**
     * Build the set of apps to exclude based on --exclude-apps and --exclude-apps-file options.
     * If neither option is specified, returns default set containing "com.android.systemui".
     * If user specifies apps, the default is NOT included - user must add it explicitly if needed.
     */
    private fun buildExcludeAppsSet(): Set<String> {
        val appsFromOption = excludeApps.map { it.trim() }.filter { it.isNotEmpty() }

        val appsFromFile = excludeAppsFile?.let { file ->
            if (file.exists() && file.isFile) {
                file.readLines()
                    .map { it.trim() }
                    .filter { it.isNotEmpty() && !it.startsWith("#") }
            } else {
                emptyList()
            }
        } ?: emptyList()

        // If user specified any apps (via option or file), use only those (no default)
        // If nothing specified, use the default
        return if (appsFromOption.isEmpty() && appsFromFile.isEmpty()) {
            setOf("com.android.systemui")
        } else {
            (appsFromOption + appsFromFile).toSet()
        }
    }
}
